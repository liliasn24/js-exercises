<h1>Split()</h1>
<p>The split method divides a string into an ordered list of substrings, puts these substrings into an array, and returns the array. The division is done by searching for a pattern; wher the pattern is provided as the first parameter in the method's call.
    split()
    split(separator)
    split(separator, limit)
</p>

<h1>Splice()</h1>
<p>The splice() method changes the contents of an array by removing or replacing existing elements and/or adding new elements in place.

splice(start)
splice(start, deleteCount)
splice(start, deleteCount, item1)
splice(start, deleteCount, item1, item2, itemN)
</p>

<h1>Slice</h1>
<p>The slice() method returns a shallow copy of a portion of an array into a new array object selected from start to end (end not included) where start and end represent the index of items in that array. The original array will not be modified.

    slice();
    slice(start);
    slice(start, end);
</p>

<h1>Spread syntax</h1>
<p>Spread syntax can be used when all elements from an object or array need to be included in a list of some kind.</p>

<p>What is CS?
    Problem solving, including engeneering, computer, tech. How computers works, the theory behind or the study of problems, standardized solutions to those problems and how to make those solutions more efficient
</p>

<p>What is an Algorithm?
    Simply put, an algorithm is a process. A set of instructions that tells a computer how to solve a problem.
    Sort and Search algorithms.
    Sorts organizes data, search finds a specific thing.
    Time: The maximum amount of time it would take the algorithm to solve a problem.
    Space: The maximum amount of computer memory, or RAM, the algorithm needs to run.
</p>

<p>Big O Notation
    Algorithm complexity. Time and Space efficency. By knowing the complexity of the data we can select the best apporach.

    Interviewers want to make sure that you understand the difference between efficiency and inefficiency so that you aren’t writing code that takes excessive memory or energy to run.

You could be asked to look at an algorithm, determine its Big O complexity, and give your reasoning. If so, keep the following considerations in mind:

Does the function have to go through an entire list? If so, there’s an N in that Big O class somewhere.
Are there nested loops? That might give you O(N^2) (or worse).
Does the function break the list into smaller chunks? You could have O(log(N)).
Is the amount of work the same, regardless of the size of the data set? You might have O(1).
You could also be asked to describe how a given function could be rewritten more efficiently. As you’ve probably realized, most functions can be written in multiple ways. Big O helps you understand the most efficient way to write functions.
</p>

<h1>Recursion</h1>

<p>In a nut shell recursion is when a function calls itself, like a loop, it helps you break down a problem in smaller parts.

We can break down the process of a recursive function into three steps:

Base case: When the process can stop.
Action: Put that function to work!
Recursive case: The function is called again but with the assurance that progress is being made toward the base case.
</p>