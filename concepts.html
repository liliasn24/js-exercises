<h1>Split()</h1>
<p>The split method divides a string into an ordered list of substrings, puts these substrings into an array, and returns the array. The division is done by searching for a pattern; wher the pattern is provided as the first parameter in the method's call.
    split()
    split(separator)
    split(separator, limit)
</p>

<h1>Splice()</h1>
<p>The splice() method changes the contents of an array by removing or replacing existing elements and/or adding new elements in place.

splice(start)
splice(start, deleteCount)
splice(start, deleteCount, item1)
splice(start, deleteCount, item1, item2, itemN)
</p>

<h1>Slice</h1>
<p>The slice() method returns a shallow copy of a portion of an array into a new array object selected from start to end (end not included) where start and end represent the index of items in that array. The original array will not be modified.

    slice();
    slice(start);
    slice(start, end);
</p>

<h1>Spread syntax</h1>
<p>Spread syntax can be used when all elements from an object or array need to be included in a list of some kind.</p>

<p>What is CS?
    Problem solving, including engeneering, computer, tech. How computers works, the theory behind or the study of problems, standardized solutions to those problems and how to make those solutions more efficient
</p>

<p>What is an Algorithm?
    Simply put, an algorithm is a process. A set of instructions that tells a computer how to solve a problem.
    Sort and Search algorithms.
    Sorts organizes data, search finds a specific thing.
    Time: The maximum amount of time it would take the algorithm to solve a problem.
    Space: The maximum amount of computer memory, or RAM, the algorithm needs to run.
</p>

<p>Big O Notation
    Algorithm complexity. Time and Space efficency. By knowing the complexity of the data we can select the best apporach.

    Interviewers want to make sure that you understand the difference between efficiency and inefficiency so that you aren’t writing code that takes excessive memory or energy to run.

You could be asked to look at an algorithm, determine its Big O complexity, and give your reasoning. If so, keep the following considerations in mind:

Does the function have to go through an entire list? If so, there’s an N in that Big O class somewhere.
Are there nested loops? That might give you O(N^2) (or worse).
Does the function break the list into smaller chunks? You could have O(log(N)).
Is the amount of work the same, regardless of the size of the data set? You might have O(1).
You could also be asked to describe how a given function could be rewritten more efficiently. As you’ve probably realized, most functions can be written in multiple ways. Big O helps you understand the most efficient way to write functions.
0(1) - this is the most efficient. -constant complexity. The function will run once, no matter the size of the input. 
0(N) - Linear Complexity. For this type of algorithm, as the input size increases, the processing time increases linearly (one extra input = one more step for the code to perform). 
0(log(N)) - Logarithmic Complexity: A Highly Efficient Algorithm. This type of algorithm cuts the problem in half each time. This makes them fast and efficient! 
0(N>2) - quandratic complexity, the least - For an input with the size N, quadratically complex algorithms execute N*N times.

</p>

<h1>Recursion</h1>

<p>In a nut shell recursion is when a function calls itself, like a loop, it helps you break down a problem in smaller parts.

We can break down the process of a recursive function into three steps:

Base case: When the process can stop.
Action: Put that function to work!
Recursive case: The function is called again but with the assurance that progress is being made toward the base case.
</p>

<h1>HTTP STATUS CODES</h1>
<p>
200 Success
201 created204 No content
100 Informational
400 Client Error/bad request
401 Unauthorized
404 Not found

500 Server error/internal server error

The Best Case

An algorithm’s best-case performance is called its “Big Omega,” or Ω (that’s the Greek symbol for Omega). Big Omega describes how fast an algorithm would run if it performed the fewest possible actions on a data set. If you were sorting an already sorted set, you’d get the Big Omega value.

The Average Case

An algorithm’s average-case performance is called its “Big Theta,” or Θ (another Greek symbol). Big Theta describes the typical runtime of an algorithm.

Stability (whether or not the items in the set stay in order).
Sorting method (comparison, distribution, or a combination of the two).
The size and structure of your data (sorted, unsorted, very large, etc.).
</p>

<h1>Bubble and Insertion algorithm</h1>
<p>For bubble sort: Start at the beginning of an array of items.
    Compare the item you’re looking at to the next item in the list.
    If this item is smaller than the next one, keep it in place. If it’s greater, swap them.
    Move on to the next item.
    Repeat Steps 1–4 until you can go through the whole list without making any swaps.

    For insertion sort: each card you take moves to the place it goes comparing it the the previous card.
    https://www.youtube.com/watch?v=ROalU379l3U this video is hilarious 

</p>

<h1>HTTP Requests</h1>
<p>GET, POST, PUT/PATCH, DELETE</p>

<h1>Distribution sort</h1>
<p>bucket sort and radix sort
Bucket sort is a lot like the essay-grading scenario we just explored. It sorts elements into buckets based on their value and then uses another method to sort the elements within those bins. It can be used for integers or strings.
Radix sort operates in basically the same way as bucket sort but is only used for integers.
</p>

<h1>Reverse method</h1>
<p>The reverse() method reverses an array in place. The first element becomes the last and the last array elemetn becomes the first </p>

<h1>Join method</h1>
<p>The join() method creates and return a new string by concatenating all the elements in an array (or an array-like object), separated by comas or a specified separator string.</p>

<h1>Merge sort and quick sort</h1>
<p>These methods use a type of recursion.</p>

<h1>Merge sort continued</h1>
<p>Merge sort consists of 2 algorithms, the firs is merge sort an the second one is  merge. The 1st one splits the array in half over and over, the second one merges those pieces back together. The recursion is used on the merge sort part (it divides until it gets to the base case) </p>

<h1>What Is a Data Structure?</h1>
<p>A data “structure” is like a container that stores data in a specific, organized layout. </p>

<p>Basic data structure, the array tada.
other types:
Linked lists
stacks
queues
hash tables
sets 
binary trees 
trees
AVL trees
graphs
</p>

<h1>Linked Lists</h1>
<p>Key component of a linked list is a node, data property and next property. The last node is know as null next node or tail.
There are singly and doubly linked lists.
Singly lists go in one direction only (towards the next item in the list)
Doubly lists go backward and forward, ie the next and before song in a plylist. 

</p>

<h1>Stack and Queue</h1>
<p>Stack last in first out. ie pancakes at the top go out first.
    Queue first in first out. ie imagine a checkout line

    The other thing that stacks and queues have in common is that they can both be implemented as an array or as a linked list.
</p>

<h2>What exactly is hashing?</h2>
<p>At its most basic, hashing refers to the process of taking a key (i.e., a piece of data), scrambling it with an algorithm, and producing an index that’s used to sort the key into a hash table.

    A hash function is the algorithm that scrambles keys in order to produces indices. Rule: for the same input, the functions should always return the same output 

    A hash tables is a list-like data structure that’s designed to quickly store and retrieve key data records

    Collisions are when 2 different inputs generate the same output. 

    2 ways to address Collisions
    Open addressing (aka, probing).
    Closed addressing (aka, chaining).

    probing: If the index generated for a key is already taken, jump to somewhere else in the table to store your key. 

    The three most common types of open addressing are linear probing, quadratic probing, and double hashing

    Linear Probing
If the slot at the hashed index is occupied, look one slot to the right. Keep doing this until an open slot is found.

Quadratic Probing
If the slot at the hashed index is occupied, square the number of steps you take to the right (i.e., take one step, then four, then nine, then 16, then 25, etc.) until you find an open slot.

Double hashing 
Come up with a secondary hash function. It must not ever return 0 and it must be able to return all addresses in the table.




</p>

<h1>sets</h1>
<p>Sets are for unique values</p>

<h1>Binary Trees and Tries</h1>
<p>rotating trees to balance it</p>
<p>Graphs
    A graph is a collection of nodes, which store data, and edges, which represent relationships or connections between nodes.
    There are also two ways to represent a graph in code: an adjacency list and an adjacency matrix. At a high level:

An adjacency list uses a collection of arrays for each node.
An adjacency matrix is represented by a two-dimensional array.
There are two common ways of traversing graphs: breadth-first search and depth-first search.
</p>

<h1>Design patterns</h1>
<p> MVC =  modal, view, controller. that is a type of design 

Creational patterns
Structural patterns
Behavioral patterns
</p>

<h1>The mern stack review</h1>
<p>Professional SRC Folder Structure
    Pages - For Page Level Components
    Components - For Pieces of Pages and Reusable Components
    SCSS - For Sass StyleSheets
    Router- For React Router Files</p>

    <h1>Authentication</h1>
    <p>To work with authentication we need to dowload bcrypt and jsonwebtoken from nmp js - go to npmjs.com and search for the packages, make sure they are the right ones. copy the commands and paste them in the terminal cd in the project folder</p>

    <h1>Strict equality</h1>
    <p>The strict equality operator (===) checks whether its two operands are equal RETURNING A BOOLEAN result (this is the important part "what it returns", unlike the equality operator (==) the strict equality operator always considers operands of different types to be be different. The Equality operator (==) attemps to convert and compare operands that are of different types</p>

    <h1>String.prototype.toString()</h1>
<p>The toString() method of a string object returns a string representing the specified string.</p>

<h1>Logical AND (&&) operator</h1>
<p>The logical AND (&&) operator (logical conjunction) for a set of boolean operands will be true if and only if all the operands are true. Otherwise it will be false.</p>

<p>FPS frames per second</p>

<h1>Arrow functions structure</h1>
<p>arrowFunc=(/*parameters*/)=>//code here</p>

<h1>eval() & Function()</h1>
<p>evaluates JavaScript code represented as a string and returns its completion value. The source is parsed as a script</p>
<p>An alternative to eval is Function(). Just like eval(), Function() takes some expression as a string for execution, except, rather than outputting the result directly, it returns an anonymous function to you that you can call. `Function() (note Funtion with capital F) is a faster and more secure alternative to eval().</p>

<h1>Binary bitwise operators</h1>
<p>Bitwise operators treat their operands as a set of 32 bits (zeros and ones) and return standard JavaScript numerical values.</p>


<h1>Math.min() and Math.max()</h1>
<p>The static function Math.min() returns the lowest-valued number passed into it, or NaN if any parameter isn't a number and can't be converted into one.


    The Math.max() function returns the largest of the zero or more numbers given as input parameters, or NaN if any parameter isn't a number and can't be converted into one.

NOTE you must use the ... aka the spred operator otherwise it wont work 
</p>

<h1>Arithmetic progression</h1>
<p>Arithmetic Progression (AP) is a sequence of numbers in order, in which the difference between any two consecutive numbers is a constant value. It is also called Arithmetic Sequence.


    Sn = n/2[2a + (n − 1) × d]

    a = first term of arithmetic progression, 
    n = number of terms in the arithmetic progression and
    d = common difference.
</p>

<h1>Ternary operation</h1>
<p>Condition ? True : False </p>

<h1>Returning Arrays</h1>
<p>We can simply return an array from a function arguments by using the brackets return [arg1, arg2] </p>

<h1>Recursion</h1>
<p>Recursion is a technique for iterating over an operation by having a function call itself repeatedly until it arrives at a result. Most loops can be rewritten in a recursive style, and in some functional languages this approach to looping is the default.

    However, while JavaScript’s functional coding style does support recursive functions, we need to be aware that most JavaScript compilers are not currently optimized to support them safely.</p>

   <h1>Arrow function expressions</h1>
   <p> An arrow function expression is a compact alternative to a traditional function expression, but is limited and can't be used in all situations.
        
        There are differences between arrow functions and traditional functions, as well as some limitations:
        
        Arrow functions don't have their own bindings to this, arguments or super, and should not be used as methods.
        Arrow functions don't have access to the new.target keyword.
        Arrow functions aren't suitable for call, apply and bind methods, which generally rely on establishing a scope.
        Arrow functions cannot be used as constructors.
        Arrow functions cannot use yield, within its body.</p>

        <h1>parseInt</h1>
        <p>The parseInt() function parses a string argument and returns an integer of the specified radix (the base in mathematical numeral systems).
            parseInt(string)
        </p>

        <h1>Module operator %</h1>
        <p>This operator return a bolean result either true or flase no need to write if else statements.</p>

        <h1>Conditional (ternary) operator</h1>
        <p>The conditional (ternary) operator is the only JavaScript operator that takes three operands: a condition followed by a question mark (?), then an expression to execute if the condition is truthy followed by a colon (:), and finally the expression to execute if the condition is falsy. This operator is frequently used as an alternative to an if...else statement.

                Structure 

                ( conditions (can be more than 1) ? the output you want if true : the outpout you want if false)
        </p>

        <h1>redundantc code</h1>
        <p>if else statements:  Using an if statement in order to return boolean or to set a variable to a boolean is redundant 

            //redundant code
            function legalAge(age) {
                if(age >= 18) {
                  return true
                }
                else {
                  return false
                }
              }
              //better code
              function legalAge(age) {
                return age >= 18
              }

              even better code
              legalAge = (age) => age >= 8;

        </p>

        <h1>Reverse method</h1>
        <p>HOW TO USE IT?

            function reverse(arr) {
                return arr.reverse();
            }

            OR IN ARROW FUNCTION 

            const reverse = arr => arr.reverse();


            <!-- reverse([1, 2, 3, 4]) -->
        </p>

        <h1>GIT revisited</h1>
        <h1>
            eval()

            The eval() function evaluates JavaScript code represented as a string and returns its completion value. The source is parsed as a script.

            takes a string an evaluates as it they were numbers and operations
        </h1>
       

        <h1>Using objetcs as parameters in a function </h1>
        <p>Look at the test case, an object is like below 
            
            const myCar = new Object();
            myCar.make = 'Ford';
            myCar.model = 'Mustang';
            myCar.year = 1969;
        
         you can access the properties if an object with the dot Notation
         example myCar.model will give you Mustang.

         the you can perform the operations you want with the properties of the object  see example in script file line 425
         
        </p>

        <p>this is how you use the ternary operator with more than one conditions. ie you just ass another ? for every condition 
            
            const equilibrium = x => x > 0 ? 'positive' : x < 0 ? 'negative' : true;
            
        </p>

        <h1>ES6 In Depth: Destructuring</h1>
        <p>ES6 In Depth is a series on new features being added to the JavaScript programming language in the 6th Edition of the ECMAScript standard, ES6 for short.

            What is destructuring assignment?
Destructuring assignment allows you to assign the properties of an array or object to variables using syntax that looks similar to array or object literals. This syntax can be extremely terse, while still exhibiting more clarity than the traditional property access.

Without destructuring assignment, you might access the first three items in an array like this:

var first = someArray[0];
var second = someArray[1];
var third = someArray[2];
        </p>

        <p>Math.floor()
            console.log(Math.floor(5.95)); = 6

            Math.floor(n / (w * h))
        </p>

        